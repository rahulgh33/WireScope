package ratelimit
package ratelimit
























































































































































}	return nil	delete(m.requests, key)func (m *InMemoryRateLimiter) Reset(ctx context.Context, key string) error {// Reset clears the rate limit for a key}	return true, nil	m.requests[key] = validRequests	validRequests = append(validRequests, now)	// Add current request	}		return false, nil	if len(validRequests) >= m.requestsLimit {	// Check if limit exceeded	}		}			validRequests = append(validRequests, reqTime)		if reqTime.After(windowStart) {	for _, reqTime := range requests {	var validRequests []time.Time	// Filter out old requests	requests := m.requests[key]	// Get existing requests for this key	windowStart := now.Add(-time.Duration(m.windowSeconds) * time.Second)	now := time.Now()func (m *InMemoryRateLimiter) Allow(ctx context.Context, key string) (bool, error) {// Allow checks if a request should be allowed}	}		windowSeconds: windowSeconds,		requestsLimit: requestsLimit,		requests:      make(map[string][]time.Time),	return &InMemoryRateLimiter{func NewInMemoryRateLimiter(requestsLimit, windowSeconds int) *InMemoryRateLimiter {// NewInMemoryRateLimiter creates a new in-memory rate limiter}	windowSeconds int	requestsLimit int	requests      map[string][]time.Timetype InMemoryRateLimiter struct {// InMemoryRateLimiter is a simple in-memory rate limiter (for development)}	return r.client.Close()func (r *RedisRateLimiter) Close() error {// Close closes the Redis connection}	return r.client.Del(ctx, key).Err()func (r *RedisRateLimiter) Reset(ctx context.Context, key string) error {// Reset clears the rate limit for a key}	return true, nil	}		return false, fmt.Errorf("failed to set expiration: %w", err)	if err := r.client.Expire(ctx, key, time.Duration(r.windowSeconds)*time.Second).Err(); err != nil {	// Set expiration on the key	}		return false, fmt.Errorf("failed to add request: %w", err)	}).Err(); err != nil {		Member: fmt.Sprintf("%d", now),		Score:  float64(now),	if err := r.client.ZAdd(ctx, key, &redis.Z{	// Add current request with score = timestamp	}		return false, nil	if count >= int64(r.requestsLimit) {	// Check if limit exceeded	}		return false, fmt.Errorf("failed to count requests: %w", err)	if err != nil && err != redis.Nil {	count, err := countCmd.Result()	}		return false, fmt.Errorf("redis pipeline error: %w", err)	if _, err := pipe.Exec(ctx); err != nil && err != redis.Nil {	// Execute pipeline	countCmd := pipe.ZCount(ctx, key, fmt.Sprintf("%d", windowStart), fmt.Sprintf("%d", now))	// Count requests in current window	pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart))	// Remove old entries outside the window	pipe := r.client.Pipeline()	windowStart := now - int64(r.windowSeconds)	now := time.Now().Unix()func (r *RedisRateLimiter) Allow(ctx context.Context, key string) (bool, error) {// Uses sliding window counter algorithm// Allow checks if a request should be allowed based on the rate limit}	}, nil		windowSeconds: windowSeconds,		requestsLimit: requestsLimit,		client:        client,	return &RedisRateLimiter{	}		return nil, fmt.Errorf("failed to connect to Redis: %w", err)	if err := client.Ping(ctx).Err(); err != nil {	defer cancel()	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)	// Test connection	})		WriteTimeout: 3 * time.Second,		ReadTimeout:  3 * time.Second,		DialTimeout:  5 * time.Second,		DB:           0,		Password:     "",		Addr:         redisAddr,	client := redis.NewClient(&redis.Options{func NewRedisRateLimiter(redisAddr string, requestsLimit, windowSeconds int) (*RedisRateLimiter, error) {// NewRedisRateLimiter creates a new Redis-backed rate limiter}	windowSeconds int	requestsLimit int	client        *redis.Clienttype RedisRateLimiter struct {// RedisRateLimiter implements distributed rate limiting using Redis}	Reset(ctx context.Context, key string) error	Allow(ctx context.Context, key string) (bool, error)type RateLimiter interface {// RateLimiter defines the interface for rate limiting)	"github.com/go-redis/redis/v8"	"time"	"fmt"	"context"import (